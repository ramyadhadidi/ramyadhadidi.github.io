---
title: 'Software is Dead? You Bet'
date: 2026-02-08
permalink: /entries/sw-llm-1/
author_profile: false
---
# Software is Dead? You Bet.

These days, with market predictions and new in the light LLM models, people think software is going to be dead. Or at least what we thought of software traditionally. I'm still pessimistic about this claim.

Agents might be new branding, but using LLMs to solve software implementation is not new. Most of us have tried it by now. Sometimes it's the fastest way to get an answer. Sometimes it's best to help you write a basic demo. I actually built [mvp-llm-dv](https://github.com/ramyadhadidi/mvp-llm-dv), which is basically in line with all these "help AI build chips, do verification without a human in the loop" hype. Honestly, it works. It was an awe moment for me.

But let's be real.

## The Problem Nobody Talks About

If you're working in a software repo, you should intimately know every piece of it. This becomes even more critical in any language. Take Python: each line, each library, could cost you performance because they represent thousands of lines in other libraries. Take C++, or C: you'd better check what each line is doing closely.

Loading an agent to manipulate code for you? Works most of the time. But the end result is not always what you want. It messes the repo. It doesn't get your philosophy in coding. Yes, for someone who hasn't coded, or hasn't run a single program, this is impressive. But for someone who cares about every little space, every dependency, every assumption? It's not impressive at all.

This is what Steven Sinofsky means when he calls the "software is dead" narrative "nonsense": we won't have less software, we'll have more [[1]](#ref1). The demand is still massively unmet. What changes is what "writing software" looks like.

## Where the Agents Break Down

In a Python codebase, one "small" library import can drag in thousands of lines of behavior you didn't explicitly approve. In C/C++, it's even more unforgiving: performance, memory layout, undefined behavior don't care that the agent sounded confident.

This is the "inner loop vs outer loop" split [[2]](#ref2). Agents can be great at the rapid inner loop: generate code, iterate quickly. But they struggle with the outer loop: requirements, architecture, tradeoffs, long term maintainability, and accountability.

I've seen it happen. An agent makes a change that passes all tests but violates an invariant you've held for years. Or breaks performance in ways that won't show up until production. Or subtly changes behavior in edge cases you forgot to test. The code looks plausible. It runs. It's wrong.

## My Experience with LLM-DV

I'm not a DV engineer. I worked with several closely to realize architecture decisions, but I cannot be one. As any job, it requires attention to details, experience, hunches, creativity. The mvp-llm-dv repo worked; it could write basic tests, it could get syntax correct most of the time. But it was still a tool.

It didn't tell me where I should spend more time. It didn't tell me what IPs could be problematic. It didn't understand how dynamic behavior changes things. It couldn't tell me which corner cases matter and which don't. It couldn't build intuition about what breaks in production versus what breaks in simulation.

That's the gap. The LLM can generate a test that compiles and runs. But a real DV engineer knows which tests actually matter, knows the failure modes before they happen, knows where the design is brittle. That knowledge comes from years of seeing things break, from understanding the domain deeply, from developing hunches about what to look for.

You can't prompt your way into that kind of expertise.

## What "Software is Dead" Actually Means

To credit the software is dead crowd, I should mention that yes, hiring people to do mundane coding tasks is probably over. Writing Python for some basic experiment in machine learning, writing a frontend and backend for a web server, writing crypto contracts: work that took me a week to learn and deploy can now happen in less than an hour.

This is what Andrej Karpathy calls "vibe coding" [[3]](#ref3): you give in to the vibes and almost forget the code exists.

But two questions matter:
1. Are you really learning anything? No.
2. Can you deploy that as a product? I don't think so.

Thanks that era is over. It was getting out of hand; you could become a Software Engineer by knowing basics in coding and earn much more than any other job requiring extensive training.

But here's what Jensen Huang gets right when he calls "software is dead" the "most illogical thing in the world" [[4]](#ref4): software is a tool. The tool doesn't vanish because we got a new kind of power tool.

## The Stronger Version

The strongest version of the "software is dead" claim isn't "no more software." It's this:
- Commodity software margins compress (because bespoke CRUD becomes cheap)
- Distribution and integration become the moat (workflows, data, trust, compliance)
- Winning teams shift from "writing code" to "owning outcomes"

Benedict Evans frames this well: the "AI maximalist" fantasy is to "replace all software with a prompt" [[5]](#ref5). He's skeptical. Instead, AI gets embedded into products as features, not as a single product that deletes the rest of the stack.

## What Doesn't Go Away

Software isn't dead. Typing might be. Boilerplate might be. The "learn framework X and grind tickets" career track probably shrinks.

But engineering doesn't go away. Responsibility doesn't go away. And correctness gets harder, not easier, when part of your system is stochastic.

This isn't an argument against LLMs. It's an argument against confusing acceleration with mastery. Against hand waving away the hard parts of building systems that matter.

A recent academic paper puts it well: software engineering will evolve, as it always has. The real work includes constraints, tradeoffs, and lifecycle management, not just code generation [[6]](#ref6).

So no, software isn't dead. But if you think it is, you probably weren't building anything that mattered in the first place.

---

## References

<a id="ref1"></a>[1] Steven Sinofsky, ["Death of software. Nah."](https://hardcoresoftware.learningbyshipping.com/p/death-of-software-nah)

<a id="ref2"></a>[2] Inner loop vs outer loop in software development: the rapid iteration cycle vs. the strategic decision cycle

<a id="ref3"></a>[3] Andrej Karpathy's coinage of "vibe coding" in discussions of LLM assisted programming

<a id="ref4"></a>[4] Jensen Huang quote via Constellation Research coverage of Cisco AI event

<a id="ref5"></a>[5] Benedict Evans, ["Generative AI: what software gets made?"](https://www.ben-evans.com/benedictevans/2024/5/21/generative-ai-what-software-gets-made)

<a id="ref6"></a>[6] Matt Welsh et al., "AI Will Not Devour Software Engineering" (ACM Onward! 2024)